package transactor.language;

// Import declarations generated by the SALSA compiler, do not modify.
import java.io.IOException;
import java.util.Vector;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;

import salsa.language.Actor;
import salsa.language.ActorReference;
import salsa.language.Message;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import gc.WeakReference;
import salsa.language.Token;
import salsa.language.exceptions.*;
import salsa.language.exceptions.CurrentContinuationException;

import salsa.language.UniversalActor;

import salsa.naming.UAN;
import salsa.naming.UAL;
import salsa.naming.MalformedUALException;
import salsa.naming.MalformedUANException;

import salsa.resources.SystemService;

import salsa.resources.ActorService;

// End SALSA compiler generated import delcarations.

import java.io.*;
import java.util.*;
import gc.*;

// NOTE: The order of execution of worldview modification is important in some methods
public class Transactor extends UniversalActor  {

	public static ActorReference getReferenceByName(UAN uan)	{ return new Transactor(false, uan); }
	public static ActorReference getReferenceByName(String uan)	{ return Transactor.getReferenceByName(new UAN(uan)); }
	public static ActorReference getReferenceByLocation(UAL ual)	{ return new Transactor(false, ual); }

	public static ActorReference getReferenceByLocation(String ual)	{ return Transactor.getReferenceByLocation(new UAL(ual)); }
	public Transactor(boolean o, UAN __uan)	{ super(false,__uan); }
	public Transactor(boolean o, UAL __ual)	{ super(false,__ual); }
	public Transactor()		{  }

	public UniversalActor construct (Transactor self) {
		Object[] __arguments = { self };
		this.send( new Message(this, this, "construct", __arguments, null, null) );
		return this;
	}

	public UniversalActor construct () {
		Object[] __arguments = {  };
		this.send( new Message(this, this, "construct", __arguments, null, null) );
		return this;
	}

	public class State extends UniversalActor .State {
		public Transactor self;
		public void updateSelf(ActorReference actorReference) {}

		public State() {
			this(null, null);
		}

		public State(UAN __uan, UAL __ual) {
			super(__uan, __ual);
			addClassName( "transactor.language.Transactor$State" );
			addMethodsForClasses();
		}

        public void process(Message msg) {}

		private Worldview wv;
        // Do we need this? or just use UAN/UAL
		private String name;
        
        /* 
         * Super constructor must be called from subclasses of transactors
         * Transactor complier would need to insert super(name) into the construct method 
         * self is needed since subclasses do not override its parents memeber variables 
         * so we need access to self in these methods
         */
		public void construct(Transactor self){
            // TODO: Create a weak transactor reference instead to not rely on passing up self reference from subclass
            // Future implementation might want to include wv info for dep passing in Message objects
			this.self = ((Transactor)self);
			if (self.getUAN()!=null) 
                this.name = self.getUAN().toString();
			else 
                this.name = self.getUAL().toString();
			wv = new Worldview();
			HashMap new_histMap = new HashMap();
			new_histMap.put(name, new History());
			wv.setHistMap(new_histMap);
            this.setWV(wv);
		}
        
        /* 
         * For instantiating the Transactor class without subclassing
         * This construct should not be used
         */
		public void construct(){
			if (self.getUAN()!=null) 
                this.name = self.getUAN().toString();
			else 
                this.name = self.getUAL().toString();
			wv = new Worldview();
			HashMap new_histMap = new HashMap();
			new_histMap.put(name, new History());
			wv.setHistMap(new_histMap);
		}

		public void setWV(Worldview wv) {
			this.wv = wv;
		}

        /*
         * recvMsg resolves Worldview dependencies before passing message into mailbox
         */
		public void recvMsg(Message msg, Worldview msg_wv) {
			Worldview union = wv.union(msg_wv);
			HashSet current = new HashSet();
			current.add(name);
			if (union.invalidates(wv.getHistMap(), current)) {
				if (wv.getHistMap().get(name).isPersistent()) {
					
                    System.out.println("roll back cause of dep\n\n");
					Worldview new_wv = new Worldview();
					HashMap new_histMap = new HashMap();
					new_histMap.put(name, union.getHistMap().get(name));
					new_wv.setHistMap(new_histMap);

					this.rollback(true, new_wv);
                    if (isDestroyed())
                        return;
                   
                    // Message remains and resend to recheck dependencies
                    // recvMsg(msg, msg_wv)
                    Object args[] = { msg, msg_wv };
                    Message pass_msg = new Message( self, self, "recvMsg", args, null, null, false );
                    self.send(pass_msg);
				}
				else {
					this.destroy();
				}
			}
			else if (union.invalidates(msg_wv.getHistMap(), msg_wv.getRootSet())) {
                wv = union;
                System.out.println("message invalidated~~~~~~~~~~~~\n"+msg+"\n");
                System.out.println("message wv: \n" + msg_wv + "\n\n");
                // Message is invalidate so we send ack and ignore
                responseAck(msg);
                wv.setRootSet(new HashSet());
			}
			else {
				wv = union;
                //System.out.println("Got msg: " + msg + "\n\n");
                // TODO: Put in beginning of mailbox
                // Salsa priority bug?
				self.send(msg);
			}
		}

        /*
         * sendMsg calls recvMsg of recipient with msg and wv arguements
         * Continuation might be able to handled internally in Message object 
         */
		public void sendMsg(String method, Object[] params, Transactor recipient) {
			Message msg = new Message(self, recipient, method, params, null, null);
			Object[] msg_property = new Object[0];
			msg.setProperty("priority", msg_property);
            // recipient<-recvMsg(msg, this.wv)
            Object args[] = { msg, this.wv };
            Message recvMsg = new Message( self, recipient, "recvMsg", args, null, null );
            //System.out.println("Sending msg: " + msg + "\n\n");
            __messages.add(recvMsg);
		}
        
        /* 
         * newTActor -> returns new Transactor with dependencies set of parent and child 
         * adds new t to histMap for both
         * adds t to root set of parent
         * sets depGraph to t dependent on parents root set plus parent
         * Should be called as such .newTActor(new [Transactor Class]([args]))
         */
		public Transactor newTActor(Transactor new_T) {
			String new_name;
			if (new_T.getUAN()!=null) 
                new_name = new_T.getUAN().toString();
			else 
                new_name = new_T.getUAL().toString();
			wv.getHistMap().put(new_name, new History());
			wv.getDepGraph().put(new_name, new HashSet());
			wv.getDepGraph().get(new_name).add(name);
			Iterator i = wv.getRootSet().iterator();
			while (i.hasNext()) {
				wv.getDepGraph().get(new_name).add((String)i.next());
			}
			wv.getRootSet().add(new_name);
			Worldview new_wv = new Worldview(wv.getHistMap(), wv.getDepGraph(), new HashSet());
            // new_T<-setWV(new_wv)
            Object args[] = { new_wv };
            Message msg = new Message( self, new_T, "setWV", args, null, null );
            Object[] propInfo = {  };
            msg.setProperty( "priority", propInfo );
            new_T.send(msg);

			return new_T;
		}

		public void stabilize() {
			wv.getHistMap().get(name).stabilize();
            // TODO: Save stable state
            // stable and checkpointed saved states would need to be seperate
            // when reloading we reload last saved state (stable or checkpoint) if suddent failure
            // we reload last checkpoint only on normal run time rollback
            // need to determine most recent saved state (stable/checkpoint) to load upon recovery from failure
            // how to recover from failure?
            // on system start, each transactor check for saved state?
		}

		public boolean dependent() {
			return !wv.independent(name);
		}

        // TODO: extend with USL and ftp protocol with better filenaming scheme
		public void checkpoint() {
			if (!dependent()&&wv.getHistMap().get(name).isStable()) {
				wv.getHistMap().get(name).checkpoint();
				HashMap new_histMap = new HashMap();
				new_histMap.put(name, wv.getHistMap().get(name));
				wv = new Worldview();
				wv.setHistMap(new_histMap);

                // Empty mailboxes so we don't stored messages with state
                Vector temp_mailbox = mailbox;
                Hashtable temp_pendingMessages = pendingMessages;
                Vector temp_unresolvedTokens = unresolvedTokens;
                mailbox = new Vector();
                pendingMessages = new Hashtable();
                unresolvedTokens = new Vector();
                /* 
                UAN myUAN = getUAN();
                UAL myUAL = getUAL();

                // Add "_saved" suffixes for appropriate state reloading to avoid conflicts with placeholder during rollback
                // Any loading of saved state needs to remove pre/suffixes to restore uan/ual
                if (myUAN != null)
                    setUAN(new UAN(myUAN.toString() + "_saved"));
                setUAL(new UAL(myUAL.toString() + "_saved"));
                */
				try {
					FileOutputStream fileOut = new FileOutputStream("./"+name.charAt(name.length()-1)+".ser");
					ObjectOutputStream out = new ObjectOutputStream(fileOut);
					out.writeObject(this);
					out.close();
					fileOut.close();
				}
				catch (IOException e) {
					e.printStackTrace();
				}
                
                // Place messages back in mailboxes
                mailbox.addAll(temp_mailbox);
                pendingMessages.putAll(temp_pendingMessages);
                unresolvedTokens.addAll(temp_unresolvedTokens);
                
                //setUAN(myUAN);
                //setUAL(myUAL);
                
			}
			else {
				wv.setRootSet(new HashSet());
			}
		}

		public Transactor self() {
			this.getTState();
			return ((Transactor)self);
		}
/*
        public void finishRollback(Worldview new_wv, Vector new_mailbox, Hashtable new_pendingMessages, Vector new_unresolvedTokens) {
            this.wv = new_wv;
            this.mailbox = new_mailbox;
            this.pendingMessages = new_pendingMessages;
            this.unresolvedTokens = new_unresolvedTokens;
            UAN tempUAN = getUAN();
            UAL tempUAL = getUAL();
            ServiceFactory.getNaming().remove(tempUAN, tempUAL);
            ServiceFactory.getNaming().delete(tempUAN);
            ServiceFactory.getTheater().removeSecurityEntry(tempUAN.toString());
            if (tempUAN != null)
                // Removing the "_saved" suffix
                setUAN(new UAN(tempUAN.toString().substring(0, tempUAN.toString().length()-6)));
            setUAL(new UAL(tempUAL.toString().substring(0, tempUAL.toString().length()-6)));
            UAN restoredUAN = getUAN();
            UAL restoredUAL = getUAL();
            Actor removed = ServiceFactory.getNaming().remove(restoredUAN, restoredUAL);
            RunTime.deletedUniversalActor();
            ServiceFactory.getNaming().setEntry(restoredUAN, restoredUAL, (Actor)this);
            if (restoredUAN != null){
                ServiceFactory.getTheater().registerSecurityEntry(restoredUAN.toString());
                ServiceFactory.getNaming().update(restoredUAN, restoredUAL);
            }
            if (removed instanceof Rollbackholder)
                ((Rollbackholder)removed).sendAllMessages();
        }
*/

        /* 
         * False: Programatic rollback
         * True: Dependency rollback
         * TODO: extend with USL and filename scheme
         */
		public void rollback(boolean force, Worldview updatedWV) {
			if (!wv.getHistMap().get(name).isStable()||force) {
				if (wv.getHistMap().get(name).isPersistent()) {
                    System.out.println(self + ": rolling back...........");
                   
                    // We need to send out previous messages first to carry on current worldview before a rollback
                    sendGeneratedMessages();

                    // Create a placeholder to collect messages while the transactor is in the process of rolling back
                    UAN savedUAN = getUAN();
                    UAL savedUAL = getUAL();
                    ServiceFactory.getNaming().setEntry(savedUAN, savedUAL, new Rollbackholder(savedUAN, savedUAL));
                    SystemService localSystem = ServiceFactory.getSystem();
                  
					wv.getHistMap().get(name).rollback();
					HashMap new_histMap = new HashMap();
					new_histMap.put(name, wv.getHistMap().get(name));
					Worldview new_wv = new Worldview();
					new_wv.setHistMap(new_histMap);

                    if (updatedWV != null)
                        new_wv = updatedWV;

					try {
						FileInputStream fileIn = new FileInputStream("./"+name.charAt(name.length()-1)+".ser");
						ByteArrayOutputStream bos = new ByteArrayOutputStream();
						byte[] buffer = new byte[1024];
						int readbytes = fileIn.read(buffer);
						while (readbytes!=-1) {
							bos.write(buffer, 0, readbytes);
							readbytes = fileIn.read(buffer);
						}
						byte[] savedState = bos.toByteArray();
						fileIn.close();
                        
                        ActorMemory mem = getActorMemory();
                        Object[] reloadArgs = { savedState, new_wv, mailbox, pendingMessages, unresolvedTokens, mem };
                        Message reloadMsg = new Message(self, localSystem, "reloadTransactor", reloadArgs, null, null, false);
                        localSystem.send(reloadMsg);
                        /* 
                        WeakReference savedStateRef;
                        if (savedUAN != null) {
                            savedStateRef = new WeakReference(new UAN(savedUAN.toString() + "_saved"), new UAL(savedUAL.toString() + "_saved"));
                        }
                        else {
                            savedStateRef = new WeakReference(null, new UAL(savedUAL.toString() + "_saved"));
                        }
                        Object savedRef = null;
                        // Waits until saved state is reloaded
                        while (savedRef == null) {
                            savedRef = ServiceFactory.getNaming().getTarget(savedStateRef);
                        }
                        
                        Object[] finishRollbackArgs = { new_wv, mailbox, pendingMessages, unresolvedTokens };
                        Message finishRollbackMsg = new Message(self, savedRef, "finishRollback", finishRollbackArgs, token1, null, false);
                        ((UniversalActor)savedRef).send(finishRollbackMsg);
                        */
                        
                        this.forceAllRefSilent();
                        // This stops this states thread to cause this actor to "die" 
                        // TODO: Implement a new indicator for rollbacking transactors in salsa
                        // maybe we can just override run() and live() and add a rolledback boolean to check for
                        this.rollingback = true;
					}
					catch (IOException i) {
						i.printStackTrace();
						return;
					}

				}
				else {
					this.destroy();
                    // Messages after a rollback is theoretically illegal...
                    __messages.clear();
				}
			}
			else {
				wv.setRootSet(new HashSet());
			}
		}

		public String getString() {
			return name+" -> "+wv.getHistMap().get(name).toString()+"\n"+wv.toString();
		}

        /* 
         * how to handle static member variables? serialize them?
         * if one transactor sets it how do others see dependency? 
         * one can checkpoint/set state because of static content set by other 
         * and other rollback but wont be recognized cause no dep
         * if self is seperately contained, can we access direct members in subclass state?
         * compiler syntax for setting state?
         */
		public boolean setTState() {
			if (!wv.getHistMap().get(name).isStable()) {
				if (!wv.getDepGraph().containsKey(name)) {
					wv.getDepGraph().put(name, new HashSet());
				}
				Iterator i = wv.getRootSet().iterator();
				while (i.hasNext()) {
					wv.getDepGraph().get(name).add((String)i.next());
				}
				return true;
			}
			return false;
		}
        
        /*
         * cannot orride getState() of Thread Class
         * need to handle member variables retrieval 
         */
		public Object getTState() {
			wv.getRootSet().add(name);
			return null;
		}
	}
}
