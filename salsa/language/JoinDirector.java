package salsa.language;

// Import declarations generated by the SALSA compiler, do not modify.
import java.io.IOException;
import java.util.Vector;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;

import salsa.language.Actor;
import salsa.language.ActorReference;
import salsa.language.Message;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import gc.WeakReference;
import salsa.language.Token;
import salsa.language.exceptions.*;
import salsa.language.exceptions.CurrentContinuationException;

import salsa.language.UniversalActor;

import salsa.naming.UAN;
import salsa.naming.UAL;
import salsa.naming.MalformedUALException;
import salsa.naming.MalformedUANException;

import salsa.resources.SystemService;

import salsa.resources.EnvironmentalService;

// End SALSA compiler generated import delcarations.

import java.util.Vector;

public class JoinDirector extends UniversalActor implements EnvironmentalService {
	public static void main(String args[]) {
		UAN uan = null;
		UAL ual = null;
		if (System.getProperty("uan") != null) {
			uan = new UAN( System.getProperty("uan") );
			ServiceFactory.getTheater();
			RunTime.receivedUniversalActor();
		}
		if (System.getProperty("ual") != null) {
			ual = new UAL( System.getProperty("ual") );

			if (uan == null) {
				System.err.println("Actor Creation Error:");
				System.err.println("	uan: " + uan);
				System.err.println("	ual: " + ual);
				System.err.println("	Identifier: " + System.getProperty("identifier"));
				System.err.println("	Cannot specify an actor to have a ual at runtime without a uan.");
				System.err.println("	To give an actor a specific ual at runtime, use the identifier system property.");
				System.exit(0);
			}
			RunTime.receivedUniversalActor();
		}
		if (System.getProperty("identifier") != null) {
			if (ual != null) {
				System.err.println("Actor Creation Error:");
				System.err.println("	uan: " + uan);
				System.err.println("	ual: " + ual);
				System.err.println("	Identifier: " + System.getProperty("identifier"));
				System.err.println("	Cannot specify an identifier and a ual with system properties when creating an actor.");
				System.exit(0);
			}
			ual = new UAL( ServiceFactory.getTheater().getLocation() + System.getProperty("identifier"));
		}
		JoinDirector instance = (JoinDirector)new JoinDirector(uan, ual).construct();
		{
			Object[] _arguments = { args };
			instance.send( new Message(instance, instance, "act", _arguments, null, null) );
		}
	}

	public static ActorReference getReferenceByName(UAN uan)	{ return new JoinDirector(false, uan); }
	public static ActorReference getReferenceByName(String uan)	{ return JoinDirector.getReferenceByName(new UAN(uan)); }
	public static ActorReference getReferenceByLocation(UAL ual)	{ return new JoinDirector(false, ual); }

	public static ActorReference getReferenceByLocation(String ual)	{ return JoinDirector.getReferenceByLocation(new UAL(ual)); }
	public JoinDirector(boolean o, UAN __uan)	{ super(__uan); }
	public JoinDirector(boolean o, UAL __ual)	{ super(__ual); }

	public JoinDirector(UAN __uan)	{ this(__uan, null); }
	public JoinDirector(UAL __ual)	{ this(null, __ual); }
	public JoinDirector()		{ this(null, null);  }
	public JoinDirector(UAN __uan, UAL __ual) {
		if (__ual != null && !__ual.getLocation().equals(ServiceFactory.getTheater().getLocation())) {
			createRemotely(__uan, __ual, "salsa.language.JoinDirector");
		} else {
			State state = new State(__uan, __ual);
			state.updateSelf(this);
			ServiceFactory.getNaming().setEntry(state.getUAN(), state.getUAL(), state);
			if (getUAN() != null) ServiceFactory.getNaming().update(state.getUAN(), state.getUAL());
		}
	}

	public UniversalActor construct (int requiredTokens, Vector targetActors, Vector targetMessages, Vector targetPositions) {
		Object[] __arguments = { new Integer(requiredTokens), targetActors, targetMessages, targetPositions };
		this.send( new Message(this, this, "construct", __arguments, null, null) );
		return this;
	}

	public UniversalActor construct() {
		Object[] __arguments = { };
		this.send( new Message(this, this, "construct", __arguments, null, null) );
		return this;
	}

	public class State extends UniversalActor.State implements salsa.resources.EnvironmentalServiceState {
		public JoinDirector self;
		public void updateSelf(ActorReference actorReference) {
			((JoinDirector)actorReference).setUAL(getUAL());
			((JoinDirector)actorReference).setUAN(getUAN());
			self = new JoinDirector(false,getUAL());
			self.setUAN(getUAN());
			self.setUAL(getUAL());
			self.muteGC();
		}

		public State() {
			this(null, null);
		}

		public State(UAN __uan, UAL __ual) {
			super(__uan, __ual);
			addClassName( "salsa.language.JoinDirector$State" );
			addMethodsForClasses();
		}

		public void construct() {}

		public void process(Message message) {
                  Method[] matches = getMatches(message.getMethodName());
                  Object returnValue = null;
                  Exception exception = null;

                  if (matches != null) {
                    for (int i = 0; i < matches.length; i++) {
                      try {
                        if (matches[i].getParameterTypes().length != message.getArguments().length) continue;
                        returnValue = matches[i].invoke(this, message.getArguments());
                      } catch (Exception e) {
                        if (e.getCause() instanceof CurrentContinuationException) {
                          sendGeneratedMessages();
                          return;
                        } else if (e instanceof InvocationTargetException) {
                          sendGeneratedMessages();
                          exception = (Exception)e.getCause();
                          break;
                        } else {
                          continue;
                        }
                      }
                      sendGeneratedMessages();
                      currentMessage.resolveContinuations(returnValue);
                      return;
                    }
                  }

                  System.err.println("Message processing exception:");
                  if (message.getSource() != null) {
                    System.err.println("\tSent by: " + message.getSource().toString());
                  } else System.err.println("\tSent by: unknown");
                  System.err.println("\tReceived by actor: " + toString());
                  System.err.println("\tMessage: " + message.toString());
                  if (exception == null) {
                    if (matches == null) {
                      System.err.println("\tNo methods with the same name found.");
                      return;
                    }
                    System.err.println("\tDid not match any of the following: ");
                    for (int i = 0; i < matches.length; i++) {
                      System.err.print("\t\tMethod: " + matches[i].getName() + "( ");
                      Class[] parTypes = matches[i].getParameterTypes();
                      for (int j = 0; j < parTypes.length; j++) {
                        System.err.print(parTypes[j].getName() + " ");
                      }
                      System.err.println(")");
                    }
                  } else {
                    System.err.println("\tThrew exception: " + exception);
                    exception.printStackTrace();
                  }
                }

                int index=0;
                int requiredTokens;
                Object[] values;
                Vector targetActors;
                Vector targetMessages;
                Vector targetPositions;
                long timeout=0;
                public void construct(int requiredTokens, Vector targetActors, Vector targetMessages, Vector targetPositions){
                  this.requiredTokens = requiredTokens;
                  this.targetActors = targetActors;
                  this.targetMessages = targetMessages;
			this.targetPositions = targetPositions;
                        values = new Object[requiredTokens];
                      }
		public void resolveJoinToken(Integer tokenPosition, Object value) {
			values[index] = value;
                        if (index==0 && timeout>0) {
                          ServiceFactory.getTransport().timeoutSend(timeout,self);
                        }
//System.out.println("JD:::"+ getUAL() +" input="+index+"/"+requiredTokens);
			index++;
			if (requiredTokens==index) {
				for (int i = 0; i<targetActors.size(); i++){
					ActorReference target = (ActorReference)targetActors.get(i);
					String messageId = (String)targetMessages.get(i);
					Integer position = (Integer)targetPositions.get(i);
					Object[] arguments = new Object[3];
					arguments[0] = messageId;
					arguments[1] = position;
					if (position.intValue()==-3) arguments[2] = null;
					else arguments[2] = values;
                                        Message data=new Message(((JoinDirector)self), target, "resolveToken", arguments, null, null,false);
					target.send(data);
				}
				this.ServiceDie();
			}
		}

                public void setTimeout(Long timeout) {
                  this.timeout=timeout.longValue();
                  if (index>1) {
                    ServiceFactory.getTransport().timeoutSend(this.timeout,self);
                  }
                }

                public boolean timeoutMsg() {
                  for (int i = 0; i < targetActors.size(); i++) {
                    ActorReference target = (ActorReference)targetActors.get(i);
                    String messageId = (String)targetMessages.get(i);
                    Integer position = (Integer)targetPositions.get(i);

                    /**
                     * If the value is a large object, it isn't required to be sent
                     * if this token is being used for synchronization.  We can send
                     * null instead.
                     */
                    Object[] arguments = new Object[3];
                    arguments[0] = messageId;
                    arguments[1] = position;
                    Object[] ret=new Object[index];
                    System.arraycopy(values,0,ret,0,index);
                    if (position.intValue() == -3) arguments[2] = null;
                    else arguments[2] = ret;
                      Message data=new Message(((JoinDirector)self), target, "resolveToken", arguments, null, null,false) ;
                    target.send( data);
                  }
                  this.ServiceDie();
                  return true;
                }
              }
            }