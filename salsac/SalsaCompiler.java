package salsac;

/**
 * $Id: SalsaCompiler.java,v 1.5 2010/06/11 05:49:42 wangw5 Exp $
 *
 * This is the Salsa programming language compiler.  Compilation goes
 * through two major steps:
 *
 * (1) Parsing phase:  Here we call the Salsa Parser.
 *                     As generated by JavaCC with a few changes to keep
 *                     the input for code generation.
 *
 * (2) Code Generation phase:  Here we use the abstract syntax tree
 *                             produced by the first phase to build
 *                             Java files corresponding to the original
 *                             Salsa files being compiled.
 * Modified by Robin D. Toll	2001/12
 *		-Re-coded parameter handling.
 * Modified by Travis Desell	2003/7
 *		-Re-write of the grammer and code generation for salsa 0.6.0
 *
 * @author Carlos Varela   cvarela@uiuc.edu   1999/09/14
 * @version 0.3.3 2002/04/02
 */

import java.io.*;

import java.util.StringTokenizer;
import java.util.Vector;

public class SalsaCompiler {
        //actMethodExist: check if method act() exists
        public static boolean actMethodExist=false;
        public static boolean isService=false;
	public static final String VERSION = "1.1.5";

	private String[] files = null;

        //a patch required for isAcotr()
        private static String currentFile=null;

	public static String moduleName = "";
	public static String extendsName = "";
	public static String actorName = "";
	public static String getModuleName()		{ return moduleName; }
	public static String getExtendsName()		{ return extendsName; }
	public static String getActorName()		{ return actorName; }
	public static Vector implementNames = new Vector();
	public static Vector getImplementNames()	{ return implementNames; }

	public static String classPaths[];

	public static Vector packages = new Vector();
	public static Vector imports = new Vector();
	public static Vector getPackages()		{ return packages; }
	public static Vector getImports()		{ return imports; }

//modification by weijen
//problem: incorrectly parsing classpath by isActor
//target: 1. parse windows and then unix classpath correctly
//        2. try current working directory
	public static boolean isActor(String objectName) {
		if (classPaths == null) {
			StringTokenizer stringTokenizerWin = new StringTokenizer(System.getProperty("java.class.path", "."), ";");
			String[] classPathsWin = new String[ stringTokenizerWin.countTokens()];
                        int classPathWinSize=0;
                        int classPathUnixSize=0;
                        //parsing Win-like classpath
			for (int i = 0; i < stringTokenizerWin.countTokens(); i++) {
				classPathsWin[i] = stringTokenizerWin.nextToken();
                                classPathWinSize++;
			}
                        //parsing unix-like classpath
                        StringTokenizer stringTokenizerUnix = new StringTokenizer(System.getProperty("java.class.path", "."), ":");
                        String[] classPathsUnix = new String[ stringTokenizerUnix.countTokens()];
                        for (int i = 0; i < stringTokenizerUnix.countTokens(); i++) {
                                classPathsUnix[i] = stringTokenizerUnix.nextToken();
                                classPathUnixSize++;
                        }
                        classPaths=new String[classPathUnixSize+classPathWinSize];
                        //copy Win-like classpath to classPath[]
                        for (int i = 0; i < classPathWinSize; i++) {
                                classPaths[i] = classPathsWin[i];
                        }
                        //copy Win-like classpath to classPath[]
                        for (int i = 0; i < classPathUnixSize; i++) {
                                classPaths[i+classPathWinSize] = classPathsUnix[i];
                        }
		}

		if (objectName.equals(actorName)) {
			return true;
		} else {
			File testFile;

                        //testing if the actor is defined in classpath
			for (int i = 0; i < classPaths.length; i++) {
				testFile = new File(classPaths[i] + File.separator + objectName + ".salsa");
				if (testFile.isFile()) return true;
			}

                        //testing if the actor is defined in the imported classes
			for (int i = 0; i < imports.size(); i++) {
				String importName = (String)imports.get(i);
				for (int j = 0; j < classPaths.length; j++) {
					if ((objectName.length() <= importName.length()) && importName.substring(importName.length() - objectName.length()).equals(objectName)) {
						testFile = new File( classPaths[j] + File.separator + convertToPath(importName) + ".salsa" );
						if (testFile.isFile()) return true;
					}
				}
			}

                        //testing if the actor is defined in the package
			for (int i = 0; i < packages.size(); i++) {
				String path = convertToPath( (String)packages.get(i) );

                                //check current working directory
				for (int j = 0; j < classPaths.length; j++) {
					testFile = new File( classPaths[j] + File.separator + path + File.separator + objectName + ".salsa" );
					if (testFile.isFile()) return true;
				}
			}

                        //testing if the actor is defined in an absolute path
                        if (currentFile!=null) {
                          testFile=new File(currentFile);
                          if (testFile.getParent()!=null) {
                            File anotherTestFile = new File(testFile.getParent()+ File.separator +objectName + ".salsa");
                            if (anotherTestFile.isFile()) return true;
                          } else {
                            File anotherTestFile = new File("."+ File.separator +objectName + ".salsa");
                            if (anotherTestFile.isFile()) return true;
                            anotherTestFile = new File(objectName + ".salsa");
                            if (anotherTestFile.isFile()) return true;
                          }
                        }
		}

		return false;
	}

	public static String convertToPath(String objectName) {
		StringTokenizer stringTokenizer = new StringTokenizer(objectName, ".");

		String path = "";
		while (stringTokenizer.hasMoreTokens()) {
			path += stringTokenizer.nextToken();
			if (stringTokenizer.hasMoreTokens()) path += File.separator;
		}
		return path;
	}

	public static void addPackage(String packageName) {
		packages.add(packageName);
	}
	public static void addImport(String importName) {
		imports.add(importName);
	}


        public static SymbolTable symbolTable = new SymbolTable();
        public static int indent = 0;

	public static salsac.definitions.CompilationUnit compilationUnit = null;
	public static salsac.definitions.CompilationUnit getCompilationUnit() { return compilationUnit; }

        public static String getIndent() {
                String code = "";
                for (int i = 0; i < indent; i++) {
                        code += "\t";
                }
                return code;
        }


	public static void main(String args[]) {
		new SalsaCompiler(args);
	}

	SalsaCompiler(String[] args) {
		SalsaParser parser = null;
		String outputFile = null;

		if (args.length == 0) {
			if (System.getProperty("silent") == null) {
				System.out.println("Salsa Compiler Version " + VERSION + ":  Reading from standard input . . .");
				parser = new SalsaParser(System.in);
			}
		} else {
			for (int x = 0; x < args.length; x++) {
				if (args[x].equals("-?")) help();
				else addFile( args[x] );
			}

			if ((files == null) || (files.length < 1)) {
				if (System.getProperty("silent") == null) {
					System.out.println("Salsa Compiler Version " + VERSION + ":  Reading from standard input . . .");
				}
				parser = new SalsaParser(System.in);
			}

			for (int x = 0; x < files.length; x++) {
				if (System.getProperty("silent") == null) {
					System.out.println();
					System.out.println("Salsa Compiler Version " + VERSION + ":  Reading from file " + files[x] + " . . .");
				}

				try {
                                        actMethodExist=false;  //gc patch
                                        if (System.getProperty( "service" )!=null){isService=true;} else {isService=false;}  //gc patch

					indent = 0;
					moduleName = "";
					actorName = "";
					extendsName = "";
					symbolTable = new SymbolTable();
					imports.clear();
					packages.clear();
					implementNames.clear();

					if (x == 0) {
						parser = new SalsaParser(new java.io.FileInputStream(files[x]));
					} else {
						parser.ReInit(new java.io.FileInputStream(files[x]));
					}

					if ( !files[x].endsWith(".salsa") ) {
						System.out.println("Salsa Compiler Version " + VERSION + ":  File must end with \".salsa\"");
					} else { // Okay, it's passed all our tests; lets actually compile it.
						outputFile = files[x].substring(0, files[x].length()-6).concat(".java");
					}
                                        currentFile=files[x];

					try {
						SimpleNode n = parser.CompilationUnit();
						compilationUnit = (salsac.definitions.CompilationUnit)n;

						if (System.getProperty("silent") == null) {
							System.out.println("Salsa Compiler Version " + VERSION + ":  Salsa program parsed successfully.");
						}

						if (outputFile != null) {
							// cvarela: if it exists, it should rename it...
							new FileOutputStream(outputFile).write( n.getJavaCode().getBytes() );
						} else {
							System.out.println( n.getJavaCode() );
						}

						if (System.getProperty("silent") == null) {
							System.out.println("Salsa Compiler Version " + VERSION + ":  Salsa program compiled successfully.");
						}
					} catch (IOException e) {
						System.out.println(e.getMessage());
						System.out.println("Salsa Compiler Version " + VERSION + ":  Encountered errors writing to file:"+outputFile);
					} catch (ParseException e) {
						System.out.println(e.getMessage());
						System.out.println("Salsa Compiler Version " + VERSION + ":  Encountered errors during parse.");
					}
				} catch (java.io.FileNotFoundException e) {
					System.out.println("Salsa Compiler Version " + VERSION + ":  File " + files[x] + " not found.");
				}

			}
		}
	}

	private static void help() {
		System.out.println("Salsa Compiler Version " + VERSION + ":  Usage is one of:");
		System.out.println("         java SalsaCompiler < inputfile");
		System.out.println("OR");
		System.out.println("         java SalsaCompiler inputfile");
		System.exit(1);
	}

	private void addFile(String fn) {
		if (files == null) {
			files = new String[1];
			files[0] = fn;
		} else {
			String[] tmp = new String[files.length+1];
			System.arraycopy(files, 0, tmp, 0, files.length);
			tmp[files.length] = fn;
			files = tmp;
		}
	}
}
