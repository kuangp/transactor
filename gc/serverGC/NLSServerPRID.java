package gc.serverGC;

// Import declarations generated by the SALSA compiler, do not modify.
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.ObjectInputStream;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.LinkedList;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;

import salsa.language.Actor;
import salsa.language.ActorReference;
import salsa.language.Message;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import salsa.language.Token;
import salsa.language.exceptions.*;
import salsa.language.exceptions.CurrentContinuationException;

import salsa.language.UniversalActor;

import salsa.naming.UAN;
import salsa.naming.UAL;
import salsa.naming.MalformedUALException;
import salsa.naming.MalformedUANException;

// End SALSA compiler generated import delcarations.

import salsa.language.Placeholder;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import salsa.naming.NamingService;
import java.lang.reflect.Constructor;
import salsa.resources.SystemService;
import gc.*;
public class NLSServerPRID extends UniversalActor implements SystemService {
        public static void main(String args[]) {
                UAN uan = null;
                UAL ual = null;
                if (System.getProperty("uan") != null) {
                        uan = new UAN( System.getProperty("uan") );
                        ServiceFactory.getTheater();
                        RunTime.receivedUniversalActor();
                }
                if (System.getProperty("ual") != null) {
                        ual = new UAL( System.getProperty("ual") );

                        if (uan == null) {
                                System.err.println("Actor Creation Error:");
                                System.err.println("	uan: " + uan);
                                System.err.println("	ual: " + ual);
                                System.err.println("	Identifier: " + System.getProperty("identifier"));
                                System.err.println("	Cannot specify an actor to have a ual at runtime without a uan.");
                                System.err.println("	To give an actor a specific ual at runtime, use the identifier system property.");
                                System.exit(0);
                        }
                        RunTime.receivedUniversalActor();
                }
                if (System.getProperty("identifier") != null) {
                        if (ual != null) {
                                System.err.println("Actor Creation Error:");
                                System.err.println("	uan: " + uan);
                                System.err.println("	ual: " + ual);
                                System.err.println("	Identifier: " + System.getProperty("identifier"));
                                System.err.println("	Cannot specify an identifier and a ual with system properties when creating an actor.");
                                System.exit(0);
                        }
                        ual = new UAL( ServiceFactory.getTheater().getLocation() + System.getProperty("identifier"));
                }
                NLSServerPRID instance = (NLSServerPRID)new NLSServerPRID(uan, ual).construct();
                {
                        Object[] _arguments = { args };
                        instance.send( new Message(instance, instance, "act", _arguments, null, null) );
                }
        }

        public static ActorReference getReferenceByName(UAN uan)	{ return new NLSServerPRID(false, uan); }
        public static ActorReference getReferenceByName(String uan)	{ return NLSServerPRID.getReferenceByName(new UAN(uan)); }
        public static ActorReference getReferenceByLocation(UAL ual)	{ return new NLSServerPRID(false, ual); }

        public static ActorReference getReferenceByLocation(String ual)	{ return NLSServerPRID.getReferenceByLocation(new UAL(ual)); }
        public NLSServerPRID(boolean o, UAN __uan)	{ super(__uan); }
        public NLSServerPRID(boolean o, UAL __ual)	{ super(__ual); }

        public NLSServerPRID(UAN __uan)	{ this(__uan, null); }
        public NLSServerPRID(UAL __ual)	{ this(null, __ual); }
        public NLSServerPRID()		{ this(null, null);  }
        public NLSServerPRID(UAN __uan, UAL __ual) {
                if (__ual != null && !__ual.getLocation().equals(ServiceFactory.getTheater().getLocation())) {
                        createRemotely(__uan, __ual, "gc.serverGC.NLSServerPRID",null);
                } else {
                        State state = new State(__uan, __ual);
                        state.updateSelf(this);
                        ServiceFactory.getNaming().setEntry(state.getUAN(), state.getUAL(), state);
                        if (getUAN() != null) ServiceFactory.getNaming().update(state.getUAN(), state.getUAL());
                }
        }

        public UniversalActor construct () {
                Object[] __arguments = {  };
                this.send( new Message(this, this, "construct", __arguments, null, null) );
                return this;
        }

        public class State extends UniversalActor.State implements salsa.resources.EnvironmentalServiceState{
          public WeakReference self;
          public void updateSelf(ActorReference actorReference) {
            self = new WeakReference( actorReference);
            self.setUAN(getUAN());
            self.setUAL(getUAL());
            actorReference.setUAL(getUAL());
            actorReference.setUAN(getUAN());
          }

          public State() {
            this(null, null);
          }

          public State(UAN __uan, UAL __ual) {
            super(__uan, __ual);
            addClassName("gc.serverGC.NLSServerPRID$State");
            addMethodsForClasses();
          }

          public void process(Message message) {
            Method[] matches = getMatches(message.getMethodName());
            Object returnValue = null;
            Exception exception = null;

            if (matches != null) {
              for (int i = 0; i < matches.length; i++) {
                try {
                  if (matches[i].getParameterTypes().length !=
                      message.getArguments().length)
                    continue;
                  returnValue = matches[i].invoke(this, message.getArguments());
                }
                catch (Exception e) {
                  if (e.getCause()instanceof CurrentContinuationException) {
                    sendGeneratedMessages();
                    return;
                  }
                  else if (e instanceof InvocationTargetException) {
                    sendGeneratedMessages();
                    exception = (Exception) e.getCause();
                    break;
                  }
                  else {
                    continue;
                  }
                }
                sendGeneratedMessages();
                currentMessage.resolveContinuations(returnValue);
                return;
              }
            }

            System.err.println("Message processing exception:");
            if (message.getSource() != null) {
              System.err.println("\tSent by: " + message.getSource().toString());
            }
            else
              System.err.println("\tSent by: unknown");
            System.err.println("\tReceived by actor: " + toString());
            System.err.println("\tMessage: " + message.toString());
            if (exception == null) {
              if (matches == null) {
                System.err.println("\tNo methods with the same name found.");
                return;
              }
              System.err.println("\tDid not match any of the following: ");
              for (int i = 0; i < matches.length; i++) {
                System.err.print("\t\tMethod: " + matches[i].getName() + "( ");
                Class[] parTypes = matches[i].getParameterTypes();
                for (int j = 0; j < parTypes.length; j++) {
                  System.err.print(parTypes[j].getName() + " ");
                }
                System.err.println(")");
              }
            }
            else {
              System.err.println("\tThrew exception: " + exception);
              exception.printStackTrace();
            }
          }

          NamingService namingService = ServiceFactory.getNaming();
          public void construct() {
          }








          /**********************************************************************
           *Non-local reachable garbage collection server
           * Org: WWC, RPI
           * Author:Wei-Jen Wang
           * Description: The server gathers pure non-local reachable virtual actor
           *              to identify if there is garbage.
           **********************************************************************/

          //actor variables
          Vector client;
          Vector workingClient;
          int GCSeconds=60;
          Hashtable actorList;
          LinkedList BFSVector;
          Vector victimList;

          public void act(String args[]) {
            UAL remoteUAL;
            client=new Vector();
            BFSVector=new LinkedList();
            workingClient=new Vector();
            actorList=new Hashtable();
            victimList=new Vector();
            try {
              int newGCSeconds = Integer.parseInt(args[0]);
              if (newGCSeconds>0) {GCSeconds=newGCSeconds;}
            }
            catch (Exception e) {
              System.err.println(e);
              System.err.println("Garbage Collection Server Failed!");
              System.err.println("Usage:java -cp <required lib> gc.serverGC.NLSServerPRID GC_Period_in_Secs <host1> <host2> ...");
              this.GCdie();
            }


            for (int i=1;i<args.length;i++) {
              try {
                if (args[i].length() > 0 &&
                    args[i].charAt(args[i].length() - 1) == '/') {
                  remoteUAL = new UAL(args[i] + "salsa/System");
                }
                else {
                  remoteUAL = new UAL(args[i] + "/salsa/System");
                }
              }catch (Exception e) {continue;}
              WeakReference remoteSystem = new WeakReference( (UniversalActor)
                  UniversalActor.getReferenceByLocation(remoteUAL));
              client.addElement(remoteSystem);
            }
            listen();
          }


          int currentSec=0;
          Message migrationMsg;
          public void listen() {
              try {sleep(500);} catch (Exception e) {}
              currentSec+=1;
              migrationMsg=null;
              if (currentSec>=this.GCSeconds*2) {
                currentSec=0;
                startServerGC();
                getVirtualMigration();
                markAndSweep();
                requestKilling();
              }
              Object[] args={};
              if (migrationMsg!=null) {self.send(migrationMsg);}
              self.send(new Message(self,self,"listen",args,false));
          }

          public void requestKilling() {
            String myName;
            for (int i = 0; i < client.size(); i++) {
              WeakReference remoteSystem = (WeakReference) client.get(i);
              if (getUAN() != null) { myName = this.getUAN().toString(); }
              else { myName = this.getUAL().toString(); }

              Object[] args = {myName,victimList};
              remoteSystem.send(new Message(self, remoteSystem, "requestKilling",
                                            args, false));
            }
          }


          //after this phase the victimList has the information
          // of the garbage actors
          public void markAndSweep() {
            BFSVector.clear();
            //pseudo root and global root identification
            for (Enumeration e = actorList.elements();  e.hasMoreElements(); ) {
              VirtualActor va=(VirtualActor) e.nextElement();
              if (va.pseudoRoot) {
                BFSVector.addLast(va);
              }
              else { //check if the actor has another remote reference
                for (int i=0;i<va.iList.length;i++) {
                  if (actorList.get(va.iList[i])==null) {
                    va.pseudoRoot=true;
                    BFSVector.addLast(va);
                    break;
                  }
                }
              }
            }

            //BFS marking from the pseudo root
            for (;;) {
              VirtualActor currentActor;
              try{
                currentActor = (VirtualActor) BFSVector.removeFirst();
              } catch (java.util.NoSuchElementException e) {break;}

              for (int i=0;i<currentActor.fList.length;i++) {
                VirtualActor next;
                try{
                  next = (VirtualActor) actorList.get(currentActor.fList[i]);

                  if (next.pseudoRoot || next.mark || next==null) { continue;}
                  else {
                    next.mark=true;
                    BFSVector.addLast(next);
                  }
                }catch (java.lang.NullPointerException e) {
                  continue;
                }
              }
            }
            victimList.clear();

            //identify the garbage actors
            for (Enumeration e = actorList.elements();  e.hasMoreElements(); ) {
              VirtualActor va=(VirtualActor) e.nextElement();
              if (!va.pseudoRoot && !va.mark) {victimList.addElement(va.name);}
            }
          }


          //the function requests remote host to do virtual migration to this actor
          //then waiting for reply in bounded time, at most 500*100 seconds
          public void getVirtualMigration() {
            String myName;
            int sent = 0;
            for (int i = 0; i < workingClient.size(); i++) {
              WeakReference remoteSystem = new WeakReference((ActorReference) workingClient.get(i));
              if (getUAN() != null) { myName = this.getUAN().toString(); }
              else { myName = this.getUAL().toString(); }

              Object[] args = {myName};
              remoteSystem.send(new Message(self, remoteSystem, "requestVirtualMigration",
                                            args, false));
              sent++;
            }
            actorList.clear();

            for (int i = 0; i < 100; i++) {
              try { sleep(500);} catch (Exception e) {}
              Message msg;
              for (; sent > 0; ) {
                try { msg = (Message)this.mailbox.remove(0); }
                catch (Exception e) { break;}
                if (msg==null) {break;}
                if (msg.getMethodName().equals("migrate")) {migrationMsg=msg;}
                if (msg.getMethodName().equals("returnVirtualMigration")) {
                  sent--;
                  Object[] args = msg.getArguments();
                  Vector actors = ( (Vector) args[0]);
                  for (int j=0;j<actors.size();j++) {
                    VirtualActor va=(VirtualActor)actors.get(j);
                    actorList.put(va.name,va);
                  }
                }
              }
              if (sent <= 0) { break;}
            }
          }

          //the global GC actor requests local snapshot for each local host
          //then waits for at most 500*100 seconds
          public void startServerGC() {
            String myName;
            int sent = 0;
            workingClient.clear();
            for (int i = 0; i < client.size(); i++) {
              WeakReference remoteSystem = (WeakReference) client.get(i);
              if (getUAN() != null) {
                myName = this.getUAN().toString();
              }
              else {
                myName = this.getUAL().toString();
              }
              Object[] args = {
                  myName};
              remoteSystem.send(new Message(self, remoteSystem, "requestSnapShot",
                                            args, false));
              sent++;
            }

            for (int i = 0; i < 100; i++) {
              try { sleep(500);} catch (Exception e) {}
              Message msg;
              for (; sent > 0; ) {
                try { msg = (Message)this.mailbox.remove(0); }
                catch (Exception e) { break;}
                if (msg==null) {break;}
                if (msg.getMethodName().equals("migrate")) {migrationMsg=msg;}
                if (msg.getMethodName().equals("returnSnapShot")) {
                  sent--;
                  Object[] args = msg.getArguments();
                  boolean getSnapShot = ( (Boolean) args[0]).booleanValue();
                  if (getSnapShot) { this.workingClient.addElement(msg.getSource());}
                }
              }
              if (sent <= 0) { break;}
            }
          }

        }


}
