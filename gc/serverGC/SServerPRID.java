package gc.serverGC;

// Import declarations generated by the SALSA compiler, do not modify.
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.ObjectInputStream;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.LinkedList;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;

import salsa.language.Actor;
import salsa.language.ActorReference;
import salsa.language.Message;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import salsa.language.Token;
import salsa.language.exceptions.*;
import salsa.language.exceptions.CurrentContinuationException;

import salsa.language.UniversalActor;

import salsa.naming.UAN;
import salsa.naming.UAL;
import salsa.naming.MalformedUALException;
import salsa.naming.MalformedUANException;

// End SALSA compiler generated import delcarations.

import salsa.language.Placeholder;
import salsa.language.RunTime;
import salsa.language.ServiceFactory;
import salsa.naming.NamingService;
import java.lang.reflect.Constructor;
import salsa.resources.SystemService;
import gc.*;
public class SServerPRID extends UniversalActor implements SystemService {
	public static void main(String args[]) {
		UAN uan = null;
		UAL ual = null;
		if (System.getProperty("uan") != null) {
			uan = new UAN( System.getProperty("uan") );
			ServiceFactory.getTheater();
			RunTime.receivedUniversalActor();
		}
		if (System.getProperty("ual") != null) {
			ual = new UAL( System.getProperty("ual") );

			if (uan == null) {
				System.err.println("Actor Creation Error:");
				System.err.println("	uan: " + uan);
				System.err.println("	ual: " + ual);
				System.err.println("	Identifier: " + System.getProperty("identifier"));
				System.err.println("	Cannot specify an actor to have a ual at runtime without a uan.");
				System.err.println("	To give an actor a specific ual at runtime, use the identifier system property.");
				System.exit(0);
			}
			RunTime.receivedUniversalActor();
		}
		if (System.getProperty("identifier") != null) {
			if (ual != null) {
				System.err.println("Actor Creation Error:");
				System.err.println("	uan: " + uan);
				System.err.println("	ual: " + ual);
				System.err.println("	Identifier: " + System.getProperty("identifier"));
				System.err.println("	Cannot specify an identifier and a ual with system properties when creating an actor.");
				System.exit(0);
			}
			ual = new UAL( ServiceFactory.getTheater().getLocation() + System.getProperty("identifier"));
		}
      		RunTime.receivedMessage();
		SServerPRID instance = (SServerPRID)new SServerPRID(uan, ual).construct();
		{
			Object[] _arguments = { args };
			instance.send( new Message(instance, instance, "act", _arguments, null, null) );
		}
                RunTime.finishedProcessingMessage();
	}

	public static ActorReference getReferenceByName(UAN uan)	{ return new SServerPRID(false, uan); }
	public static ActorReference getReferenceByName(String uan)	{ return SServerPRID.getReferenceByName(new UAN(uan)); }
	public static ActorReference getReferenceByLocation(UAL ual)	{ return new SServerPRID(false, ual); }

	public static ActorReference getReferenceByLocation(String ual)	{ return SServerPRID.getReferenceByLocation(new UAL(ual)); }
	public SServerPRID(boolean o, UAN __uan)	{ super(__uan); }
	public SServerPRID(boolean o, UAL __ual)	{ super(__ual); }

	public SServerPRID(UAN __uan)	{ this(__uan, null); }
	public SServerPRID(UAL __ual)	{ this(null, __ual); }
	public SServerPRID()		{ this(null, null);  }
	public SServerPRID(UAN __uan, UAL __ual) {
		if (__ual != null && !__ual.getLocation().equals(ServiceFactory.getTheater().getLocation())) {
			createRemotely(__uan, __ual, "gc.serverGC.SServerPRID",null);
		} else {
			State state = new State(__uan, __ual);
			state.updateSelf(this);
			ServiceFactory.getNaming().setEntry(state.getUAN(), state.getUAL(), state);
			if (getUAN() != null) ServiceFactory.getNaming().update(state.getUAN(), state.getUAL());
		}
	}

	public UniversalActor construct () {
		Object[] __arguments = {  };
		this.send( new Message(this, this, "construct", __arguments, null, null) );
		return this;
	}

	public class State extends UniversalActor.State implements salsa.resources.EnvironmentalServiceState{
          public WeakReference self;
          public void updateSelf(ActorReference actorReference) {
            self = new WeakReference( actorReference);
            self.setUAN(getUAN());
            self.setUAL(getUAL());
            actorReference.setUAL(getUAL());
            actorReference.setUAN(getUAN());
          }

          public State() {
            this(null, null);
          }

          public State(UAN __uan, UAL __ual) {
            super(__uan, __ual);
            addClassName("gc.serverGC.SServerPRID$State");
            addMethodsForClasses();
          }

          public void process(Message message) {
            Method[] matches = getMatches(message.getMethodName());
            Object returnValue = null;
            Exception exception = null;

            if (matches != null) {
              for (int i = 0; i < matches.length; i++) {
                try {
                  if (matches[i].getParameterTypes().length !=
                      message.getArguments().length)
                    continue;
                  returnValue = matches[i].invoke(this, message.getArguments());
                }
                catch (Exception e) {
                  if (e.getCause()instanceof CurrentContinuationException) {
                    sendGeneratedMessages();
                    return;
                  }
                  else if (e instanceof InvocationTargetException) {
                    sendGeneratedMessages();
                    exception = (Exception) e.getCause();
                    break;
                  }
                  else {
                    continue;
                  }
                }
                sendGeneratedMessages();
                currentMessage.resolveContinuations(returnValue);
                return;
              }
            }

            System.err.println("Message processing exception:");
            if (message.getSource() != null) {
              System.err.println("\tSent by: " + message.getSource().toString());
            }
            else
              System.err.println("\tSent by: unknown");
            System.err.println("\tReceived by actor: " + toString());
            System.err.println("\tMessage: " + message.toString());
            if (exception == null) {
              if (matches == null) {
                System.err.println("\tNo methods with the same name found.");
                return;
              }
              System.err.println("\tDid not match any of the following: ");
              for (int i = 0; i < matches.length; i++) {
                System.err.print("\t\tMethod: " + matches[i].getName() + "( ");
                Class[] parTypes = matches[i].getParameterTypes();
                for (int j = 0; j < parTypes.length; j++) {
                  System.err.print(parTypes[j].getName() + " ");
                }
                System.err.println(")");
              }
            }
            else {
              System.err.println("\tThrew exception: " + exception);
              exception.printStackTrace();
            }
          }

          NamingService namingService = ServiceFactory.getNaming();
          public void construct() {
          }

          /**********************************************************************
           *
           **********************************************************************/

          //actor variables
          Vector client;
          Vector workingClient;
          int GCSeconds=60000;
          int timeoutTrial=600;
          int timeoutInterval=100;
          Hashtable actorList;
          LinkedList BFSVector;
          Vector victimList;

          public void act(String args[]) {

            UAL remoteUAL;
            client=new Vector();
            BFSVector=new LinkedList();
            workingClient=new Vector();
            actorList=new Hashtable();
            victimList=new Vector();
            try {
              GCSeconds = Integer.parseInt(args[0]);
            }
            catch (Exception e) {
              System.err.println(e);
              System.err.println("Garbage Collection Server Failed!");
              System.err.println("Usage:java -cp <required lib> gc.serverGC.SServerPRID GC_Period_in_Secs <host1> <host2> ...");
              System.err.println("      where <host> has the format machineAddress:port, such as jenna.cs.rpi.edu:4444");

              this.GCdie();
            }

            for (int i=1;i<args.length;i++) {
              try {
                if (args[i].length() > 0 &&
                    args[i].charAt(args[i].length() - 1) == '/') {
                  remoteUAL = new UAL("rmsp://" + args[i] + "salsa/System");
                }
                else {
                  remoteUAL = new UAL("rmsp://" + args[i] + "/salsa/System");
                }
              }catch (Exception e) {
                System.err.println(e);
                continue;
              }
              WeakReference remoteSystem = new WeakReference( (UniversalActor)
                  UniversalActor.getReferenceByLocation(remoteUAL));
              client.addElement(remoteSystem);
            }
            listen();
          }

          public void listen() {

            int currentSec=-1;
            for (;;) {
              currentSec+=1;
              if (currentSec>=this.GCSeconds*2) {
                currentSec=0;
long exect=System.currentTimeMillis();
long curr=0;
                startServerGC();
curr=System.currentTimeMillis();
//System.out.println("ss==>"+(curr-exect));
exect=curr;
                getVirtualMigration();
curr=System.currentTimeMillis();
//System.out.println("gvm==>"+(curr-exect));
exect=curr;

                markAndSweep();
curr=System.currentTimeMillis();
//System.out.println("m&s==>"+(curr-exect));
exect=curr;

                requestKilling();
curr=System.currentTimeMillis();
//System.out.println("rk==>"+(curr-exect));
exect=curr;


                if (this.GCSeconds<0) {
                  this.GCdie();
                  if (this.getUAN()==null) {System.exit(0);}
                  break;
                }
              }
              try {sleep(500);} catch (Exception e) {}
            }
          }

          public void requestKilling() {
            String myName;
            int sent=0;
            for (int i = 0; i < client.size(); i++) {
              WeakReference remoteSystem = (WeakReference) client.get(i);
              if (getUAN() != null) { myName = this.getUAN().toString(); }
              else { myName = this.getUAL().toString(); }
              sent++;
              Object[] args = {myName,victimList};
              remoteSystem.send(new Message(self, remoteSystem, "requestKilling",
                                            args, false));
            }

            for (int i = 0; i < timeoutTrial; i++) {
              try { sleep(this.timeoutInterval);} catch (Exception e) {}
              Message msg;
              for (; sent > 0; ) {
                try { msg = (Message)this.mailbox.remove(0); }
                catch (Exception e) { break;}
                if (msg==null) {break;}
                if (msg.getMethodName().equals("returnKilling")) {
                  sent--;
                }
              }
              if (sent <= 0) { break;}
            }
          }



          //after this phase the victimList has the information
          // of the garbage actors
          public void markAndSweep() {
            BFSVector.clear();

            //pseudo root and global root identification
            for (Enumeration e = actorList.elements();  e.hasMoreElements(); ) {
              VirtualActor va=(VirtualActor) e.nextElement();
              if (va.pseudoRoot) {
                BFSVector.addLast(va);
              }
              else { //check if the actor has another remote reference
                for (int i=0;i<va.iList.length;i++) {
                  if (actorList.get(va.iList[i])==null) {
                    va.pseudoRoot=true;
                    BFSVector.addLast(va);
                    break;
                  }
                }
              }
            }

            //BFS marking from the pseudo root
            for (;;) {
              VirtualActor currentActor;
              try{
                currentActor = (VirtualActor) BFSVector.removeFirst();
              } catch (java.util.NoSuchElementException e) {break;}

              for (int i=0;i<currentActor.fList.length;i++) {
                VirtualActor next;
                try{
                  next = (VirtualActor) actorList.get(currentActor.fList[i]);

                  if (next.pseudoRoot || next.mark || next==null) { continue;}
                  else {
                    next.mark=true;
                    BFSVector.addLast(next);
                  }
                }catch (java.lang.NullPointerException e) {
                  continue;
                }
              }
            }
            victimList.clear();

            //identify the garbage actors
            for (Enumeration e = actorList.elements();  e.hasMoreElements(); ) {
              VirtualActor va=(VirtualActor) e.nextElement();
              if (!va.pseudoRoot && !va.mark) {victimList.addElement(va.name);}
            }
          }


          //the function requests remote host to do virtual migration to this actor
          //then waiting for reply in bounded time, at most 500*100 seconds
          public void getVirtualMigration() {
            String myName;
            int sent = 0;
            for (int i = 0; i < workingClient.size(); i++) {
              WeakReference remoteSystem = new WeakReference((ActorReference) workingClient.get(i));
              if (getUAN() != null) { myName = this.getUAN().toString(); }
              else { myName = this.getUAL().toString(); }

              Object[] args = {myName};
              remoteSystem.send(new Message(self, remoteSystem, "requestVirtualMigration",
                                            args, false));
              sent++;
            }
            actorList.clear();

            for (int i = 0; i < timeoutTrial; i++) {
              try { sleep(this.timeoutInterval);} catch (Exception e) {}
              Message msg;
              for (; sent > 0; ) {
                try { msg = (Message)this.mailbox.remove(0); }
                catch (Exception e) { break;}
                if (msg==null) {break;}
                if (msg.getMethodName().equals("returnVirtualMigration")) {
//System.out.println("rvm:"+msg.getSource());
                  sent--;
                  Object[] args = msg.getArguments();
                  Vector actors = ( (Vector) args[0]);
                  for (int j=0;j<actors.size();j++) {
                    VirtualActor va=(VirtualActor)actors.get(j);
                    actorList.put(va.name,va);
                  }
                }
              }
              if (sent <= 0) { break;}
            }
          }

          //the global GC actor requests local snapshot for each local host
          //then waits for at most 500*100 seconds
          public void startServerGC() {
            String myName;
            int sent = 0;
            workingClient.clear();
            for (int i = 0; i < client.size(); i++) {
              WeakReference remoteSystem = (WeakReference) client.get(i);
              if (getUAN() != null) {
                myName = this.getUAN().toString();
              }
              else {
                myName = this.getUAL().toString();
              }
              Object[] args = {
                  myName};
              remoteSystem.send(new Message(self, remoteSystem, "requestSnapShot",
                                            args, false));
              sent++;
            }

            for (int i = 0; i < timeoutTrial; i++) {
              try { sleep(this.timeoutInterval);} catch (Exception e) {}
              Message msg;
              for (; sent > 0; ) {
                try { msg = (Message)this.mailbox.remove(0); }
                catch (Exception e) { break;}
                if (msg==null) {break;}
                if (msg.getMethodName().equals("returnSnapShot")) {
//System.out.println("rs:"+msg.getSource());
                  sent--;
                  Object[] args = msg.getArguments();
                  boolean getSnapShot = ( (Boolean) args[0]).booleanValue();
                  if (getSnapShot) { this.workingClient.addElement(msg.getSource());}
                }
              }
              if (sent <= 0) { break;}
            }
          }






        }


}